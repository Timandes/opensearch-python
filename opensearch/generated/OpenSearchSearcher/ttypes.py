#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import GeneralSearcher.ttypes
import shared.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class SearchType:
  SEARCH = 0
  SCROLL = 1

  _VALUES_TO_NAMES = {
    0: "SEARCH",
    1: "SCROLL",
  }

  _NAMES_TO_VALUES = {
    "SEARCH": 0,
    "SCROLL": 1,
  }

class SearchFormat:
  XML = 0
  JSON = 1
  FULLJSON = 2
  PROTOBUF = 3

  _VALUES_TO_NAMES = {
    0: "XML",
    1: "JSON",
    2: "FULLJSON",
    3: "PROTOBUF",
  }

  _NAMES_TO_VALUES = {
    "XML": 0,
    "JSON": 1,
    "FULLJSON": 2,
    "PROTOBUF": 3,
  }

class Order:
  DECREASE = 0
  INCREASE = 1

  _VALUES_TO_NAMES = {
    0: "DECREASE",
    1: "INCREASE",
  }

  _NAMES_TO_VALUES = {
    "DECREASE": 0,
    "INCREASE": 1,
  }


class Config:
  """
  Attributes:
   - appNames: app name 或 app id 或 app version
   - start
   - hits
   - searchFormat
   - customConfig: example:  query=config=start:0,hit:15,rerank_size:200,format:json,KVpairs=name:company_name,price:new_price&&query=id:'489013149'</p>

  config.setCustomConfig(Lists.newArrayList("mykey1:name#company_name,price#new_price"));


   - kvpairs: example: cluster=daogou&&kvpairs=name:company_name&&query=笔筒</p>

  config.setKvpairs("name:company_name,price:new_price");


   - fetchFields: 获取搜索结果包含的字段列表(fetch_fields)

   - routeValue: 分区查询.  routeValue为分区键所对应的值.

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'appNames', (TType.STRING,None), None, ), # 1
    (2, TType.I32, 'start', None, 0, ), # 2
    (3, TType.I32, 'hits', None, 15, ), # 3
    None, # 4
    (5, TType.I32, 'searchFormat', None,     0, ), # 5
    None, # 6
    (7, TType.LIST, 'customConfig', (TType.STRING,None), None, ), # 7
    None, # 8
    (9, TType.STRING, 'kvpairs', None, None, ), # 9
    None, # 10
    (11, TType.LIST, 'fetchFields', (TType.STRING,None), None, ), # 11
    None, # 12
    (13, TType.STRING, 'routeValue', None, None, ), # 13
  )

  def __init__(self, appNames=None, start=thrift_spec[2][4], hits=thrift_spec[3][4], searchFormat=thrift_spec[5][4], customConfig=None, kvpairs=None, fetchFields=None, routeValue=None,):
    self.appNames = appNames
    self.start = start
    self.hits = hits
    self.searchFormat = searchFormat
    self.customConfig = customConfig
    self.kvpairs = kvpairs
    self.fetchFields = fetchFields
    self.routeValue = routeValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.appNames = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString()
            self.appNames.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.start = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.hits = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.searchFormat = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.customConfig = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readString()
            self.customConfig.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.kvpairs = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.fetchFields = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readString()
            self.fetchFields.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.routeValue = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Config')
    if self.appNames is not None:
      oprot.writeFieldBegin('appNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.appNames))
      for iter18 in self.appNames:
        oprot.writeString(iter18)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I32, 2)
      oprot.writeI32(self.start)
      oprot.writeFieldEnd()
    if self.hits is not None:
      oprot.writeFieldBegin('hits', TType.I32, 3)
      oprot.writeI32(self.hits)
      oprot.writeFieldEnd()
    if self.searchFormat is not None:
      oprot.writeFieldBegin('searchFormat', TType.I32, 5)
      oprot.writeI32(self.searchFormat)
      oprot.writeFieldEnd()
    if self.customConfig is not None:
      oprot.writeFieldBegin('customConfig', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.customConfig))
      for iter19 in self.customConfig:
        oprot.writeString(iter19)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.kvpairs is not None:
      oprot.writeFieldBegin('kvpairs', TType.STRING, 9)
      oprot.writeString(self.kvpairs)
      oprot.writeFieldEnd()
    if self.fetchFields is not None:
      oprot.writeFieldBegin('fetchFields', TType.LIST, 11)
      oprot.writeListBegin(TType.STRING, len(self.fetchFields))
      for iter20 in self.fetchFields:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.routeValue is not None:
      oprot.writeFieldBegin('routeValue', TType.STRING, 13)
      oprot.writeString(self.routeValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.appNames is None:
      raise TProtocol.TProtocolException(message='Required field appNames is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.appNames)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.hits)
    value = (value * 31) ^ hash(self.searchFormat)
    value = (value * 31) ^ hash(self.customConfig)
    value = (value * 31) ^ hash(self.kvpairs)
    value = (value * 31) ^ hash(self.fetchFields)
    value = (value * 31) ^ hash(self.routeValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeepPaging:
  """

  传统搜索场景的主要目的是为了尽量短的时间内召回最符合的结果，所以对搜索结果进行了限制。在某些场景下需要提供更多的结果来进行分析工作，
  可以使用scroll接口来获取更多的结果，目前scorll只支持query与filter子句，sort子句无法支持。

  注意事项
  <pre>
   1, start值无效，通过hit值设置每次返回的结果数，即后续查询都以第一次查询指定的hit值为准；
   2, aggregate、sort、distinct、排序表达式无效，如果传入，查询会报错且无结果；
   3, 第一次查询需要完整的query、index_name、AccessKeyId等参数，后面的查询不需要传这些参数（即使传入，也会被忽略），只需要传入上一次返回的scroll_id即可；
   4, 不支持多应用scroll查询；
   5, 每次查询都必须传scroll参数，如果不传，对于第一次查询，就按正常的查询；对于后续的查询，按scroll处理，但结果中无scroll_id返回。
   6, 返回结果均有第一次查询中的format决定，后续传scroll_id的响应格式均同第一次；
   7, 如果用户传入的scroll_id是非法的，那么查询会报错，返回结果格式为json。
   8, 第一次查询将不返回实际文档数据，只返回scroll_id，需要再次访问才能拿到搜索结果。
   </pre>

  Attributes:
   - scrollExpire: 设置scroll请求的有效期

  @param expire 指定的scroll请求有效期 默认 1m 表示一分钟，支持的时间单位包括：w=Week, d=Day, h=Hour, m=minute, s=second
   - scrollId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'scrollExpire', None, "1m", ), # 1
    None, # 2
    (3, TType.STRING, 'scrollId', None, None, ), # 3
  )

  def __init__(self, scrollExpire=thrift_spec[1][4], scrollId=None,):
    self.scrollExpire = scrollExpire
    self.scrollId = scrollId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.scrollExpire = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.scrollId = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeepPaging')
    if self.scrollExpire is not None:
      oprot.writeFieldBegin('scrollExpire', TType.STRING, 1)
      oprot.writeString(self.scrollExpire)
      oprot.writeFieldEnd()
    if self.scrollId is not None:
      oprot.writeFieldBegin('scrollId', TType.STRING, 3)
      oprot.writeString(self.scrollId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.scrollExpire)
    value = (value * 31) ^ hash(self.scrollId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SortField:
  """
  Attributes:
   - field: 排序方式字段名.

   - order: 排序方式，有升序“INCREASE”和降序“DECREASE”两种方式。默认值为“DECREASE”

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field', None, None, ), # 1
    None, # 2
    (3, TType.I32, 'order', None,     0, ), # 3
  )

  def __init__(self, field=None, order=thrift_spec[3][4],):
    self.field = field
    self.order = order

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.order = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SortField')
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 1)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    if self.order is not None:
      oprot.writeFieldBegin('order', TType.I32, 3)
      oprot.writeI32(self.order)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.field is None:
      raise TProtocol.TProtocolException(message='Required field field is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field)
    value = (value * 31) ^ hash(self.order)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Sort:
  """
  排序字段及方式


  Attributes:
   - sortFields
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'sortFields', (TType.STRUCT,(SortField, SortField.thrift_spec)), None, ), # 1
  )

  def __init__(self, sortFields=None,):
    self.sortFields = sortFields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.sortFields = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = SortField()
            _elem26.read(iprot)
            self.sortFields.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Sort')
    if self.sortFields is not None:
      oprot.writeFieldBegin('sortFields', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.sortFields))
      for iter27 in self.sortFields:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sortFields)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Rank:
  """
  排序相关度及表达式


  Attributes:
   - reRankSize
   - firstRankName: 设置粗排表达式名称

   - secondRankName: 设置粗排表达式名称

  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'reRankSize', None, 200, ), # 1
    None, # 2
    (3, TType.STRING, 'firstRankName', None, None, ), # 3
    None, # 4
    (5, TType.STRING, 'secondRankName', None, None, ), # 5
  )

  def __init__(self, reRankSize=thrift_spec[1][4], firstRankName=None, secondRankName=None,):
    if reRankSize is self.thrift_spec[1][4]:
      reRankSize = 200
    self.reRankSize = reRankSize
    self.firstRankName = firstRankName
    self.secondRankName = secondRankName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reRankSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.firstRankName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.secondRankName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Rank')
    if self.reRankSize is not None:
      oprot.writeFieldBegin('reRankSize', TType.I32, 1)
      oprot.writeI32(self.reRankSize)
      oprot.writeFieldEnd()
    if self.firstRankName is not None:
      oprot.writeFieldBegin('firstRankName', TType.STRING, 3)
      oprot.writeString(self.firstRankName)
      oprot.writeFieldEnd()
    if self.secondRankName is not None:
      oprot.writeFieldBegin('secondRankName', TType.STRING, 5)
      oprot.writeString(self.secondRankName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.reRankSize)
    value = (value * 31) ^ hash(self.firstRankName)
    value = (value * 31) ^ hash(self.secondRankName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Summary:
  """
  增加了此内容后，fieldName字段可能会被截断、飘红等。


  Attributes:
   - summary_field: 指定的生效的字段。此字段必需为可分词的text类型的字段。

   - summary_len: 指定结果集返回的词字段的字节长度，一个汉字为2个字节。

   - summary_ellipsis: 指定用什么符号来标注未展示完的数据，例如“...”。

   - summary_snippet: 指定query命中几段summary内容。

   - summary_element: 指定命中的query的标红标签，可以为em等。

   - summary_element_prefix: 指定标签前缀。

   - summary_element_postfix: 指定标签后缀。

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'summary_field', None, None, ), # 1
    None, # 2
    (3, TType.STRING, 'summary_len', None, None, ), # 3
    None, # 4
    (5, TType.STRING, 'summary_ellipsis', None, "...", ), # 5
    None, # 6
    (7, TType.STRING, 'summary_snippet', None, None, ), # 7
    None, # 8
    (9, TType.STRING, 'summary_element', None, None, ), # 9
    None, # 10
    (11, TType.STRING, 'summary_element_prefix', None, None, ), # 11
    None, # 12
    (13, TType.STRING, 'summary_element_postfix', None, None, ), # 13
  )

  def __init__(self, summary_field=None, summary_len=None, summary_ellipsis=thrift_spec[5][4], summary_snippet=None, summary_element=None, summary_element_prefix=None, summary_element_postfix=None,):
    self.summary_field = summary_field
    self.summary_len = summary_len
    self.summary_ellipsis = summary_ellipsis
    self.summary_snippet = summary_snippet
    self.summary_element = summary_element
    self.summary_element_prefix = summary_element_prefix
    self.summary_element_postfix = summary_element_postfix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.summary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.summary_len = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.summary_ellipsis = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.summary_snippet = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.summary_element = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.summary_element_prefix = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.summary_element_postfix = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Summary')
    if self.summary_field is not None:
      oprot.writeFieldBegin('summary_field', TType.STRING, 1)
      oprot.writeString(self.summary_field)
      oprot.writeFieldEnd()
    if self.summary_len is not None:
      oprot.writeFieldBegin('summary_len', TType.STRING, 3)
      oprot.writeString(self.summary_len)
      oprot.writeFieldEnd()
    if self.summary_ellipsis is not None:
      oprot.writeFieldBegin('summary_ellipsis', TType.STRING, 5)
      oprot.writeString(self.summary_ellipsis)
      oprot.writeFieldEnd()
    if self.summary_snippet is not None:
      oprot.writeFieldBegin('summary_snippet', TType.STRING, 7)
      oprot.writeString(self.summary_snippet)
      oprot.writeFieldEnd()
    if self.summary_element is not None:
      oprot.writeFieldBegin('summary_element', TType.STRING, 9)
      oprot.writeString(self.summary_element)
      oprot.writeFieldEnd()
    if self.summary_element_prefix is not None:
      oprot.writeFieldBegin('summary_element_prefix', TType.STRING, 11)
      oprot.writeString(self.summary_element_prefix)
      oprot.writeFieldEnd()
    if self.summary_element_postfix is not None:
      oprot.writeFieldBegin('summary_element_postfix', TType.STRING, 13)
      oprot.writeString(self.summary_element_postfix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.summary_field is None:
      raise TProtocol.TProtocolException(message='Required field summary_field is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.summary_field)
    value = (value * 31) ^ hash(self.summary_len)
    value = (value * 31) ^ hash(self.summary_ellipsis)
    value = (value * 31) ^ hash(self.summary_snippet)
    value = (value * 31) ^ hash(self.summary_element)
    value = (value * 31) ^ hash(self.summary_element_prefix)
    value = (value * 31) ^ hash(self.summary_element_postfix)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Aggregate:
  """
  添加统计信息(aggregate)

  一个关键词通常能命中数以万计的文档，用户不太可能浏览所有文档来获取信息。而用户感兴趣的
  可 能是一些统计类的信息，比如，查询“手机”这个关键词，想知道每个卖家所有商品中的最高价格。
  则可以按照卖家的user_id分组，统计每个小组中最大的price值，例如：
  groupKey:user_id,aggFun:max(price)

  相关wiki，请查询：
  @link http://docs.aliyun.com/?spm=5176.2020520121.103.8.VQIcGd&tag=tun#/pub/opensearch/api-reference/query-clause&aggregate-clause


  Attributes:
   - groupKey: 指定需要统计的字段名称。

   - aggFun: 指定统计的方法。当前支持：count、max、min、sum等。

   - range: 指定统计范围。

   - maxGroup: 最大组个数。

   - aggFilter: 指定过滤某些统计。

   - aggSamplerThresHold: 指定抽样的阈值。

   - aggSamplerStep: 指定抽样的步长。

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'groupKey', None, None, ), # 1
    None, # 2
    (3, TType.STRING, 'aggFun', None, None, ), # 3
    None, # 4
    (5, TType.STRING, 'range', None, None, ), # 5
    None, # 6
    (7, TType.STRING, 'maxGroup', None, None, ), # 7
    None, # 8
    (9, TType.STRING, 'aggFilter', None, None, ), # 9
    None, # 10
    (11, TType.STRING, 'aggSamplerThresHold', None, None, ), # 11
    None, # 12
    (13, TType.STRING, 'aggSamplerStep', None, None, ), # 13
  )

  def __init__(self, groupKey=None, aggFun=None, range=None, maxGroup=None, aggFilter=None, aggSamplerThresHold=None, aggSamplerStep=None,):
    self.groupKey = groupKey
    self.aggFun = aggFun
    self.range = range
    self.maxGroup = maxGroup
    self.aggFilter = aggFilter
    self.aggSamplerThresHold = aggSamplerThresHold
    self.aggSamplerStep = aggSamplerStep

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.groupKey = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.aggFun = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.range = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.maxGroup = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.aggFilter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.aggSamplerThresHold = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.aggSamplerStep = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Aggregate')
    if self.groupKey is not None:
      oprot.writeFieldBegin('groupKey', TType.STRING, 1)
      oprot.writeString(self.groupKey)
      oprot.writeFieldEnd()
    if self.aggFun is not None:
      oprot.writeFieldBegin('aggFun', TType.STRING, 3)
      oprot.writeString(self.aggFun)
      oprot.writeFieldEnd()
    if self.range is not None:
      oprot.writeFieldBegin('range', TType.STRING, 5)
      oprot.writeString(self.range)
      oprot.writeFieldEnd()
    if self.maxGroup is not None:
      oprot.writeFieldBegin('maxGroup', TType.STRING, 7)
      oprot.writeString(self.maxGroup)
      oprot.writeFieldEnd()
    if self.aggFilter is not None:
      oprot.writeFieldBegin('aggFilter', TType.STRING, 9)
      oprot.writeString(self.aggFilter)
      oprot.writeFieldEnd()
    if self.aggSamplerThresHold is not None:
      oprot.writeFieldBegin('aggSamplerThresHold', TType.STRING, 11)
      oprot.writeString(self.aggSamplerThresHold)
      oprot.writeFieldEnd()
    if self.aggSamplerStep is not None:
      oprot.writeFieldBegin('aggSamplerStep', TType.STRING, 13)
      oprot.writeString(self.aggSamplerStep)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.groupKey is None:
      raise TProtocol.TProtocolException(message='Required field groupKey is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.groupKey)
    value = (value * 31) ^ hash(self.aggFun)
    value = (value * 31) ^ hash(self.range)
    value = (value * 31) ^ hash(self.maxGroup)
    value = (value * 31) ^ hash(self.aggFilter)
    value = (value * 31) ^ hash(self.aggSamplerThresHold)
    value = (value * 31) ^ hash(self.aggSamplerStep)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Distinct:
  """
  聚合打散条件(distinct)

  例如：检索关键词“手机”共获得10个结果，分别为：doc1，doc2，doc3，doc4，doc5，doc6，
  doc7，doc8，doc9，doc10。其中前三个属于用户A，doc4-doc6属于用户B，剩余四个属于
  用户C。如果前端每页仅展示5个商品，则用户C将没有展示的机会。但是如果按照user_id进行抽
  取，每轮抽取1个，抽取2次，并保留抽取剩余的结果，则可以获得以下文档排列顺序：doc1、
  doc4、doc7、doc2、doc5、doc8、doc3、doc6、doc9、doc10。可以看出，通过distinct
  排序，各个用户的 商品都得到了展示机会，结果排序更趋于合理。

  Attributes:
   - key: 为用户用于做distinct抽取的字段，该字段要求为可过滤字段。
   
   - distCount: 为一次抽取的document数量，默认值为1。
   
   - distTimes: 为抽取的次数，默认值为1。
   
   - reserved: 为是否保留抽取之后剩余的结果，true为保留，false则丢弃，丢弃时totalHits的个数会减去被distinct而丢弃的个数，但这个结果不一定准确，默认为true。
   
   - distFilter: 为过滤条件，被过滤的doc不参与distinct，只在后面的 排序中，这些被过滤的doc将和被distinct出来的第一组doc一起参与排序。默认是全部参与distinct。
   
   - updateTotalHit: 当reserved为false时，设置update_total_hit为true，则最终total_hit会减去被distinct丢弃的的数目（不一定准确），为false则不减； 默认为false。
   
   - grade: 指定档位划分阈值。
   
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    None, # 2
    (3, TType.I32, 'distCount', None, 1, ), # 3
    None, # 4
    (5, TType.I32, 'distTimes', None, 1, ), # 5
    None, # 6
    (7, TType.BOOL, 'reserved', None, True, ), # 7
    None, # 8
    (9, TType.STRING, 'distFilter', None, None, ), # 9
    None, # 10
    (11, TType.BOOL, 'updateTotalHit', None, False, ), # 11
    None, # 12
    (13, TType.STRING, 'grade', None, None, ), # 13
  )

  def __init__(self, key=None, distCount=thrift_spec[3][4], distTimes=thrift_spec[5][4], reserved=thrift_spec[7][4], distFilter=None, updateTotalHit=thrift_spec[11][4], grade=None,):
    self.key = key
    if distCount is self.thrift_spec[3][4]:
      distCount = 1
    self.distCount = distCount
    if distTimes is self.thrift_spec[5][4]:
      distTimes = 1
    self.distTimes = distTimes
    if reserved is self.thrift_spec[7][4]:
      reserved = True
    self.reserved = reserved
    self.distFilter = distFilter
    if updateTotalHit is self.thrift_spec[11][4]:
      updateTotalHit = False
    self.updateTotalHit = updateTotalHit
    self.grade = grade

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.distCount = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.distTimes = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.reserved = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.distFilter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.updateTotalHit = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.grade = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Distinct')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.distCount is not None:
      oprot.writeFieldBegin('distCount', TType.I32, 3)
      oprot.writeI32(self.distCount)
      oprot.writeFieldEnd()
    if self.distTimes is not None:
      oprot.writeFieldBegin('distTimes', TType.I32, 5)
      oprot.writeI32(self.distTimes)
      oprot.writeFieldEnd()
    if self.reserved is not None:
      oprot.writeFieldBegin('reserved', TType.BOOL, 7)
      oprot.writeBool(self.reserved)
      oprot.writeFieldEnd()
    if self.distFilter is not None:
      oprot.writeFieldBegin('distFilter', TType.STRING, 9)
      oprot.writeString(self.distFilter)
      oprot.writeFieldEnd()
    if self.updateTotalHit is not None:
      oprot.writeFieldBegin('updateTotalHit', TType.BOOL, 11)
      oprot.writeBool(self.updateTotalHit)
      oprot.writeFieldEnd()
    if self.grade is not None:
      oprot.writeFieldBegin('grade', TType.STRING, 13)
      oprot.writeString(self.grade)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.key is None:
      raise TProtocol.TProtocolException(message='Required field key is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.distCount)
    value = (value * 31) ^ hash(self.distTimes)
    value = (value * 31) ^ hash(self.reserved)
    value = (value * 31) ^ hash(self.distFilter)
    value = (value * 31) ^ hash(self.updateTotalHit)
    value = (value * 31) ^ hash(self.grade)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Suggest:
  """
  Attributes:
   - suggestName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'suggestName', None, None, ), # 1
  )

  def __init__(self, suggestName=None,):
    self.suggestName = suggestName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.suggestName = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Suggest')
    if self.suggestName is not None:
      oprot.writeFieldBegin('suggestName', TType.STRING, 1)
      oprot.writeString(self.suggestName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.suggestName is None:
      raise TProtocol.TProtocolException(message='Required field suggestName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.suggestName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Abtest:
  """
  Attributes:
   - sceneTag: 场景标签。用户在控制台上配置哪些场景需要做实验，查询中只有指定了对应场景名的query才会进行实验。
   - flowDivider: 流量分配标识。对该值进行hash，将用户查询分配到不同的实验中，该值通常可设置为最终用户的id。
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'sceneTag', None, None, ), # 1
    (2, TType.STRING, 'flowDivider', None, None, ), # 2
  )

  def __init__(self, sceneTag=None, flowDivider=None,):
    self.sceneTag = sceneTag
    self.flowDivider = flowDivider

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.sceneTag = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.flowDivider = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Abtest')
    if self.sceneTag is not None:
      oprot.writeFieldBegin('sceneTag', TType.STRING, 1)
      oprot.writeString(self.sceneTag)
      oprot.writeFieldEnd()
    if self.flowDivider is not None:
      oprot.writeFieldBegin('flowDivider', TType.STRING, 2)
      oprot.writeString(self.flowDivider)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sceneTag is None:
      raise TProtocol.TProtocolException(message='Required field sceneTag is unset!')
    if self.flowDivider is None:
      raise TProtocol.TProtocolException(message='Required field flowDivider is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sceneTag)
    value = (value * 31) ^ hash(self.flowDivider)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SearchParams:
  """
  Attributes:
   - config: config for search.
   - query: 设定指定索引字段范围的搜索关键词(query)

  此query是查询必需的一部分，可以指定不同的索引名，并同时可指定多个查询及之间的关系
  （AND, OR, ANDNOT, RANK）。

  例如查询subject索引字段的query:“手机”，可以设置为 query=subject:'手机'。

  上边例子如果查询price 在1000-2000之间的手机，其查询语句为： query=subject:'手机'
  AND price:[1000,2000]

  NOTE: text类型索引在建立时做了分词，而string类型的索引则没有分词。

  @link http://docs.aliyun.com/?spm=5176.2020520121.103.8.VQIcGd&tag=tun#/pub/opensearch/api-reference/query-clause&query-clause

   - filter: 过滤规则(filter)
   - sort: 排序字段及排序方式(sort)
   - rank
   - aggregates: 添加统计信息(aggregate)相关参数
   - distincts: 聚合打散条件
   - summaries: 动态摘要(summary)信息
   - queryProcessorNames: 设置查询分析规则(qp)
   - deepPaging
   - disableFunctions: 关闭某些功能模块(disable)

  有如下场景需要考虑：
  1、如果要关闭整个qp的功能，则指定disableValue="qp"。
  2、要指定某个索引关闭某个功能，则可以指定disableValue="qp:function_name:index_names",
    其中index_names可以用“|”分隔，可以为index_name1|index_name2...
  3、如果要关闭多个function可以用“,”分隔，例如：disableValue="qp:function_name1:index_name1,qp:function_name2:index_name1"

  qp有如下模块：
  1、spell_check: 检查用户查询串中的拼写错误，并给出纠错建议。
  2、term_weighting: 分析查询中每个词的重要程度，并将其量化成权重，权重较低的词可能不会参与召回。
  3、stop_word: 根据系统内置的停用词典过滤查询中无意义的词
  4、synonym: 根据系统提供的通用同义词库和语义模型，对查询串进行同义词扩展，以便扩大召回。

  example:
  "qp" 标示关闭整个qp
  "qp:spell_check" 标示关闭qp的拼音纠错功能。
  "qp:stop_word:index_name1|index_name2" 标示关闭qp中index_name1和index_name2上的停用词功能。

  key 需要禁用的函数名称
  value 待禁用函数的详细说明
   - customParam
   - suggest: 下拉提示是搜索服务的基础功能，在用户输入查询词的过程中，智能推荐候选query，减少用户输入，帮助用户尽快找到想要的内容。
  OpenSearch下拉提示在实现了中文前缀，拼音全拼，拼音首字母简拼查询等通用功能的基础上，实现了基于用户文档内容的query智能识别。
  用户通过控制台的简单配置，就能拥有专属的定制下拉提示。此外，控制台上还提供了黑名单，推荐词条功能，让用户进一步控制下拉提示
  的结果，实现更灵活的定制。

   - abtest: Abtest
   - userId: 终端用户的id，用来统计uv信息
   - rawQuery: 终端用户输入的query
  """

  thrift_spec = (
    None, # 0
    None, # 1
    None, # 2
    (3, TType.STRUCT, 'config', (Config, Config.thrift_spec), None, ), # 3
    None, # 4
    (5, TType.STRING, 'query', None, None, ), # 5
    None, # 6
    (7, TType.STRING, 'filter', None, None, ), # 7
    None, # 8
    (9, TType.STRUCT, 'sort', (Sort, Sort.thrift_spec), None, ), # 9
    None, # 10
    (11, TType.STRUCT, 'rank', (Rank, Rank.thrift_spec), Rank(**{
      "reRankSize" : 200,
    }), ), # 11
    None, # 12
    (13, TType.SET, 'aggregates', (TType.STRUCT,(Aggregate, Aggregate.thrift_spec)), None, ), # 13
    None, # 14
    (15, TType.SET, 'distincts', (TType.STRUCT,(Distinct, Distinct.thrift_spec)), None, ), # 15
    None, # 16
    (17, TType.SET, 'summaries', (TType.STRUCT,(Summary, Summary.thrift_spec)), None, ), # 17
    None, # 18
    (19, TType.LIST, 'queryProcessorNames', (TType.STRING,None), None, ), # 19
    None, # 20
    (21, TType.STRUCT, 'deepPaging', (DeepPaging, DeepPaging.thrift_spec), None, ), # 21
    None, # 22
    (23, TType.MAP, 'disableFunctions', (TType.STRING,None,TType.STRING,None), None, ), # 23
    None, # 24
    None, # 25
    None, # 26
    (27, TType.MAP, 'customParam', (TType.STRING,None,TType.STRING,None), None, ), # 27
    None, # 28
    (29, TType.STRUCT, 'suggest', (Suggest, Suggest.thrift_spec), None, ), # 29
    (30, TType.STRUCT, 'abtest', (Abtest, Abtest.thrift_spec), None, ), # 30
    (31, TType.STRING, 'userId', None, None, ), # 31
    (32, TType.STRING, 'rawQuery', None, None, ), # 32
  )

  def __init__(self, config=None, query=None, filter=None, sort=None, rank=thrift_spec[11][4], aggregates=None, distincts=None, summaries=None, queryProcessorNames=None, deepPaging=None, disableFunctions=None, customParam=None, suggest=None, abtest=None, userId=None, rawQuery=None,):
    self.config = config
    self.query = query
    self.filter = filter
    self.sort = sort
    if rank is self.thrift_spec[11][4]:
      rank = Rank(**{
      "reRankSize" : 200,
    })
    self.rank = rank
    self.aggregates = aggregates
    self.distincts = distincts
    self.summaries = summaries
    self.queryProcessorNames = queryProcessorNames
    self.deepPaging = deepPaging
    self.disableFunctions = disableFunctions
    self.customParam = customParam
    self.suggest = suggest
    self.abtest = abtest
    self.userId = userId
    self.rawQuery = rawQuery

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 3:
        if ftype == TType.STRUCT:
          self.config = Config()
          self.config.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.query = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.sort = Sort()
          self.sort.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.rank = Rank()
          self.rank.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.SET:
          self.aggregates = set()
          (_etype31, _size28) = iprot.readSetBegin()
          for _i32 in xrange(_size28):
            _elem33 = Aggregate()
            _elem33.read(iprot)
            self.aggregates.add(_elem33)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.SET:
          self.distincts = set()
          (_etype37, _size34) = iprot.readSetBegin()
          for _i38 in xrange(_size34):
            _elem39 = Distinct()
            _elem39.read(iprot)
            self.distincts.add(_elem39)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.SET:
          self.summaries = set()
          (_etype43, _size40) = iprot.readSetBegin()
          for _i44 in xrange(_size40):
            _elem45 = Summary()
            _elem45.read(iprot)
            self.summaries.add(_elem45)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.LIST:
          self.queryProcessorNames = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = iprot.readString()
            self.queryProcessorNames.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.deepPaging = DeepPaging()
          self.deepPaging.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.MAP:
          self.disableFunctions = {}
          (_ktype53, _vtype54, _size52 ) = iprot.readMapBegin()
          for _i56 in xrange(_size52):
            _key57 = iprot.readString()
            _val58 = iprot.readString()
            self.disableFunctions[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.MAP:
          self.customParam = {}
          (_ktype60, _vtype61, _size59 ) = iprot.readMapBegin()
          for _i63 in xrange(_size59):
            _key64 = iprot.readString()
            _val65 = iprot.readString()
            self.customParam[_key64] = _val65
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.STRUCT:
          self.suggest = Suggest()
          self.suggest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRUCT:
          self.abtest = Abtest()
          self.abtest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 31:
        if ftype == TType.STRING:
          self.userId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 32:
        if ftype == TType.STRING:
          self.rawQuery = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SearchParams')
    if self.config is not None:
      oprot.writeFieldBegin('config', TType.STRUCT, 3)
      self.config.write(oprot)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 5)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.filter is not None:
      oprot.writeFieldBegin('filter', TType.STRING, 7)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.sort is not None:
      oprot.writeFieldBegin('sort', TType.STRUCT, 9)
      self.sort.write(oprot)
      oprot.writeFieldEnd()
    if self.rank is not None:
      oprot.writeFieldBegin('rank', TType.STRUCT, 11)
      self.rank.write(oprot)
      oprot.writeFieldEnd()
    if self.aggregates is not None:
      oprot.writeFieldBegin('aggregates', TType.SET, 13)
      oprot.writeSetBegin(TType.STRUCT, len(self.aggregates))
      for iter66 in self.aggregates:
        iter66.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.distincts is not None:
      oprot.writeFieldBegin('distincts', TType.SET, 15)
      oprot.writeSetBegin(TType.STRUCT, len(self.distincts))
      for iter67 in self.distincts:
        iter67.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.summaries is not None:
      oprot.writeFieldBegin('summaries', TType.SET, 17)
      oprot.writeSetBegin(TType.STRUCT, len(self.summaries))
      for iter68 in self.summaries:
        iter68.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.queryProcessorNames is not None:
      oprot.writeFieldBegin('queryProcessorNames', TType.LIST, 19)
      oprot.writeListBegin(TType.STRING, len(self.queryProcessorNames))
      for iter69 in self.queryProcessorNames:
        oprot.writeString(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.deepPaging is not None:
      oprot.writeFieldBegin('deepPaging', TType.STRUCT, 21)
      self.deepPaging.write(oprot)
      oprot.writeFieldEnd()
    if self.disableFunctions is not None:
      oprot.writeFieldBegin('disableFunctions', TType.MAP, 23)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.disableFunctions))
      for kiter70,viter71 in self.disableFunctions.items():
        oprot.writeString(kiter70)
        oprot.writeString(viter71)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.customParam is not None:
      oprot.writeFieldBegin('customParam', TType.MAP, 27)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.customParam))
      for kiter72,viter73 in self.customParam.items():
        oprot.writeString(kiter72)
        oprot.writeString(viter73)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.suggest is not None:
      oprot.writeFieldBegin('suggest', TType.STRUCT, 29)
      self.suggest.write(oprot)
      oprot.writeFieldEnd()
    if self.abtest is not None:
      oprot.writeFieldBegin('abtest', TType.STRUCT, 30)
      self.abtest.write(oprot)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.STRING, 31)
      oprot.writeString(self.userId)
      oprot.writeFieldEnd()
    if self.rawQuery is not None:
      oprot.writeFieldBegin('rawQuery', TType.STRING, 32)
      oprot.writeString(self.rawQuery)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.config is None:
      raise TProtocol.TProtocolException(message='Required field config is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.config)
    value = (value * 31) ^ hash(self.query)
    value = (value * 31) ^ hash(self.filter)
    value = (value * 31) ^ hash(self.sort)
    value = (value * 31) ^ hash(self.rank)
    value = (value * 31) ^ hash(self.aggregates)
    value = (value * 31) ^ hash(self.distincts)
    value = (value * 31) ^ hash(self.summaries)
    value = (value * 31) ^ hash(self.queryProcessorNames)
    value = (value * 31) ^ hash(self.deepPaging)
    value = (value * 31) ^ hash(self.disableFunctions)
    value = (value * 31) ^ hash(self.customParam)
    value = (value * 31) ^ hash(self.suggest)
    value = (value * 31) ^ hash(self.abtest)
    value = (value * 31) ^ hash(self.userId)
    value = (value * 31) ^ hash(self.rawQuery)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
